# Make a new directory for the project called FYP and then make directories for the raw fastq files and FASTQC
# -p: allows for any parent directory to be created if it does not alreay exist
mkdir -p /media/newdrive/GCB2024/sallyowens/FYP/raw_fastq/FastQC

# Upload fastq files into cyberduck into raw_fastq directory. 
# Run FASTQC on files
# nohup &: allows command to run in the backround
# wildcard (*): runs command on all files ending with .fq.gz 
# --ourdir=: put the output in the desired directory (FastQC)
nohup fastqc *.fq.gz --outdir=/media/newdrive/GCB2024/sallyowens/FYP/raw_fastq/FastQC &

# run MultiQC on FastQC reports to generate summary report for quality assessment on reads
multiqc /media/newdrive/GCB2024/sallyowens/FYP/raw_fastq/FastQC

# aligning reads to reference genome using STAR, reference genome being used is UCSC hg38
# Genome indices had already been generated using the following code
# STAR --runThreadN 32 --runMode genomeGenerate --genomeDir /media/newdrive/data/Reference_genomes/Human/UCSC/STAR --genomeFastaFiles /media/newdrive/data/Reference_genomes/Human/UCSC/hg38.fa --sjdbGTFfile /media/newdrive/data/Reference_genomes/Human/UCSC/hg38.ncbiRefSeq.gtf --sjdbOverhang 149
# --runThreadN 32: to speed up the process, the tool will utilise 32 threads for the computtion
# --runMode genomeGenerate: specifie 


# this outputs files ending in _1.fq.gz, _2.fq.gz and the file with the same name, to check input files before running alignment 
for i in *_1.fq.gz; do
echo 
echo $i
echo ${i%_1.fq.gz}_2.fq.gz
echo ${i%_1.fq.gz}
echo 
done

# To test a loop to align all fastq files within a directory, dry run of STAR alignemnt step
# --genomeDir specifies the path to the directory where the genome indices are stored 
# --readFilesIn speciefies the name(s) (with path if not in the current working directory) of the fastq files containing the sequences to be mapped
# --readFilesCommand zcat specifies how fastq files are compressed, zcat indicates that they are gzipped.
# --outFileNamePrefix specifies the prefix name to give to all output files
# --outSAMtype specifies the nature of the output alignment file in this case we want a bam file, BAM SortedByCoordinate
# --outSAMunmapped specified what to do with unmapped reads. --outSAMunmapped Within means unmapped reads will be output into the SAM/BAM Aligned.* file(s)
for i in *_1.fq.gz; do
echo STAR --genomeDir /media/newdrive/data/Reference_genomes/Human/UCSC/STAR_UCSC_refseq/ --runThreadN 12 --readFilesIn $i ${i%_1.fq.gz}_2.fq.gz --readFilesCommand zcat --outFileNamePrefix ${i%_1.fq.gz} --outSAMtype BAM SortedByCoordinate --outSAMunmapped Within --outSAMattributes Standard
done


# To align all fastq files within a directory using STAR
# 
nohup sh -c 'for i in *_1.fq.gz; do
STAR --genomeDir /media/newdrive/data/Reference_genomes/Human/UCSC/STAR_UCSC_refseq/ --runThreadN 12 --readFilesIn $i ${i%_1.fq.gz}_2.fq.gz --readFilesCommand zcat --outFileNamePrefix ${i%_1.fq.gz} --outSAMtype BAM SortedByCoordinate --outSAMunmapped Within --outSAMattributes Standard
done' &

# Move bams and related files to a new directory and create a multiqc summary
mkdir -p ~/FYP/coordinate_sorted_bams
mv *.out* ~/FYP/coordinate_sorted_bams/
cd ~/FYP/coordinate_sorted_bams
multiqc ~/FYP/coordinate_sorted_bams -n STAR_multiqc

# view header only of one of the bam files, -H shows the header section only. Useful for seeing informaiton regading the sequence, the reference genome and alignment.
samtools view -H RNA_S1Aligned.sortedByCoord.out.bam

# view mapping section only of bam file. Pipe the output to a less command to keep it one screen at a time and to the width of the screen only as it is easier to view.
# alignment section will show the read name, the flag, the chromosome the read maps to and its position, the mapping quality (255 is maximum for star), the CIGAR string, mapping information on the second read and the sequence of the read
samtools view RNA_S1Aligned.sortedByCoord.out.bam | less -S

# view header and mapping section of sam file, -h is to view both header and alignment sections.
samtools view -h RNA_S1Aligned.sortedByCoord.out.bam | less -S

# count number of alignments
samtools view -c RNA_S1Aligned.sortedByCoord.out.bam #does the same thing as previous command

# samtools index
# bam files need to be indexed for a variety of downstream tools
# need to be in coordinate_sorted_bams directory for this to work
pwd # to check

# index bam files (generate bai)
# -@ specify number of threads to use
for i in *Aligned.sortedByCoord.out.bam; do
samtools index $i -@ 12
done

# RSeQC for Human data
# Make an rseqc directory and infer_experiment directory within it

mkdir -p ~/FYP/coordinate_sorted_bam/rseqc/infer_experiment

# Infer whether strand-specific RNA-seq data was performed: Only need to check this for one bam file
for i in *Aligned.sortedByCoord.out.bam; do
infer_experiment.py -r /media/newdrive/data/Reference_genomes/Human/UCSC/hg38.ncbiRefSeq.bed12 -i RNA_S1Aligned.sortedByCoord.out.bam > ~/FYP/coordinate_sorted_bam/rseqc/infer_experiment/${i%Aligned.sortedByCoord.out.bam}.infer_exp.txt
done

# Summarizing mapping statistics of a BAM file: bam_stat.py
nohup sh -c 'for i in *Aligned.sortedByCoord.out.bam; do
bam_stat.py -i $i > ~/rseqc/${i%Aligned.sortedByCoord.out.bam}.bamstats.txt
done' &

# Create read_distribution directory within rseqc
mkdir -p ~/FYP/coordinate_sorted_bam/rseqc/read_distribution

# Calculate how mapped reads were distributed over genome feature (like CDS exon, 5’UTR exon, 3’ UTR exon, Intron, Intergenic regions): read_distribution.py
nohup sh -c 'for i in *Aligned.sortedByCoord.out.bam; do
read_distribution.py -i $i -r /media/newdrive/data/Reference_genomes/Human/UCSC/hg38.ncbiRefSeq.bed12 > ~/FYP/coordinate_sorted_bam/rseqc/read_distribution/${i%Aligned.sortedByCoord.out.bam}.read_dist.txt
done' &

# Create gene_body_coverage directory within rseqc
mkdir -p ~/FYP/coordinate_sorted_bam/rseqc/gene_body_coverage

# Calculate the RNA-seq reads coverage over gene body: geneBody_coverage.py
# This checks to see if we are getting even coverage across the full length of the gene, or if there any 3' or 5' bias

# count number of alignments to know what portion of reads to subsample 
for i in *Aligned.sortedByCoord.out.bam; do
samtools view -c $i
done

# subsample a proportion of the aligned reads, to end up with ~200,000
# use a subset of the reads because it will take too long to run
# need to adjust this to suit your average number of aligned reads
for i in *Aligned.sortedByCoord.out.bam; do
samtools view -s 0.00127952 -o ${i%.bam}_subset.bam $i
done

# index subsampled bam files, test
for i in *Aligned.sortedByCoord.out_subset.bam; do
echo
echo samtools index $i
echo
done

# index subsampled bam files
for i in *Aligned.sortedByCoord.out_subset.bam; do
samtools index $i
done

# count number of alignments in subsampled bam files
for i in *Aligned.sortedByCoord.out_subset.bam; do
samtools view -c $i
done

nohup sh -c 'for i in *Aligned.sortedByCoord.out_subset.bam; do
geneBody_coverage.py -i $i -r /media/newdrive/data/Reference_genomes/Human/UCSC/hg38.ncbiRefSeq.bed12 -o ~/FYP/coordinate_sorted_bam/rseqc/gene_body_coverage/${i%Aligned.sortedByCoord.out_subset.bam}
done' &


# Run multiqc on the results

cd ~/FYP/coordinate_sorted_bam/rseqc/gene_body_coverage
multiqc ~/FYP/coordinate_sorted_bam/rseqc/gene_body_coverage -n reseqc_gene_body_coverage_multiqc

cd ~/FYP/coordinate_sorted_bam/rseqc/read_distribution
multiqc ~/FYP/coordinate_sorted_bam/rseqc/read_distribution -n reseqc_read_distribution_multiqc

cd ~/FYP/coordinate_sorted_bam/rseqc/infer_experiment
multiqc ~/FYP/coordinate_sorted_bam/rseqc/infer_experiment -n reseqc_infer_experiment_multiqc

cd ~/coordinate_sorted_bam/
mkdir ~/name_sorted_bam 

# create name-sorted bam file
# -n sort by name rather than coordinates
# -@ specify number of threads to use
# -o name of output file
for i in *Aligned.sortedByCoord.out.bam; do
samtools sort -n -@ 12 -o ~/name_sorted_bams/${i%Aligned.sortedByCoord.out.bam}_namesorted.bam $i
done

cd ~/name_sorted_bam
mkdir -p ~/FYP/counts


# for unstranded libraries

nohup sh -c 'featureCounts -T 12 -p --countReadPairs -C -a /media/newdrive/data/Reference_genomes/Human/UCSC/hg38.ncbiRefSeq.gtf -o ~/FYP/counts/featurecounts.txt *namesorted.bam 2> ~/FYP/counts/featurecounts.screen-output.log' &

# -p specifies paired-end reads
# --countReadPairs counts fragments instead of reads (only applicable for paired-end reads)
# -C means do not count read pairs that have their two ends mapping to different chromosomes or mapping to same chromosome but on different strands
# -a identifies the gene annotation gtf file
# -o specifies the name (and path) of the output counts file
# 2 is used to denote Stderr (standard error) output

# Preview the featureCounts.txt file
# less command makes it easier to see than the head command
cd ~/FYP/counts
less -S featurecounts.txt

multiqc ~/FYP/counts1 -n featurecounts_multiqc

# install packages required for the analysis in R studio
# now using R script rather than BASH
if (!require("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}


if (!require("apeglm")) {
  BiocManager::install("apeglm")
}
library(apeglm)


if (!require("DESeq2")) {
  BiocManager::install("DESeq2")
}
library(DESeq2)


if (!require("tidyverse")) {
  install.packages("tidyverse")
}
library(tidyverse)


if (!require("RColorBrewer")) {
  install.packages("RColorBrewer")
}
library(RColorBrewer)


if (!require("pheatmap")) {
  install.packages("pheatmap")
}
library(pheatmap)


if (!require("ggrepel")) {
  install.packages("ggrepel")
}
library(ggrepel)


if (!require("msigdbr")) {
  install.packages("msigdbr")
}
library(msigdbr)


if (!require("tibble")) {
  install.packages("tibble")
}
library(tibble)


if (!require("fgsea")) {
  BiocManager::install("fgsea")
}
library(fgsea)

# create a new project in R studio
# Download featurecounts.txt from the server
# read in featurecounts file
counts <- read.table("featurecounts.txt", header = TRUE)
View(counts)
row.names(counts) <- counts$Geneid
head(counts)

# remove columns 1-6 as we only need count infromation from the BAM files
counts <- counts[ , -c(1:6) ]
head(counts)

# replace column names using gsub
# gsub(pattern, replacement, x) 
# e.g. here RNA_S1_namesorted.bam will be changed to RNA_S1, RNA_met_S1_namesorted.bam will be changed to RNA_met_S1
orig_names <- names(counts)
orig_names
names(counts) <- gsub("(RNA_met_S|RNA_S)([0-9]+).*" , "\\1\\2" , orig_names)
names(counts)
head(counts)

# Identify the columns you want to remove (as there are 12 samples with poor gene body coverage) and move them to specific vector 
columns_to_remove <- c("RNA_met_S10", "RNA_S3", "RNA_S24", "RNA_S23", "RNA_S21", "RNA_S6", "RNA_S22", "RNA_S1", "RNA_S5", "RNA_S4", "RNA_S15", "RNA_met_S8")

# Remove the specified columns
# %in% columns_to_remove: matches columns in both the names(counts) and columns_to_remove
# !(...): labels columns in both as TRUE 
# counts[, ...]: selects columns not in columns_to_remove and substes them to counts 
counts <- counts[, !(names(counts) %in% columns_to_remove)]

# Print the modified count matrix
head(counts)

# Assign samples to groups; here samples will be assigned to either MT (metastasis) or NM (non metastasis)
metadata <- data.frame(metastasis=gsub(".*met.*" , "MT" , names(counts)) , row.names = names(counts))
metadata$metastasis[metadata$metastasis != "MT"] <- "NM"
metadata

# Check the data are in data.frames
class(counts)
class(metadata)

# Check that sample names match in both files
all(colnames(counts) %in% rownames(metadata))
all(colnames(counts) == rownames(metadata))

# To create the object the count matrix and metadata table is needed as input as countData and col Data respectively. Deisgn forumla also needs to be stated. This specifies the column(s) in the metadata table and how they should be used in the analysis. For this, it's metastasis or not. Other covariates can be added later in the analysis. 
# Create a DESeqDataSet.
library(DESeq2)
library(magrittr)

dds <- DESeqDataSetFromMatrix(countData = counts, colData = metadata, design = ~ metastasis)
colData(dds) %>% head
assay(dds, "counts" ) %>% head

# Make the NM group the reference group
dds$metastasis <- factor(dds$metastasis, levels = c("NM","MT"))

# Check number of rows (i.e number of genes) and remove rows/genes where there are zero counts in every sample
dim(dds)
dim(dds[rowSums(counts(dds)) > 0, ])
dds <- dds[rowSums(counts(dds)) > 0, ]

# Transform normalized counts using the rlog transformation; to improve the distances/clustering for the PCA and heirarchical clustering visualisation methods, we need to moderate the variance across the mean (i.e. make it more homoskedastic) by applying the rlog transformation to the normalized counts. The rlog transformation of the normalized counts is only necessary for these visualization methods during this quality assessment. We will not be using these tranformed counts downstream.
# Perform a regularised-logarithm transformation of the count data to make it more homoskedastic
rld <- rlog(dds, blind=TRUE)

# Compare counts in original DESeqDataSet object (dds) with transformed DESeqDataSet object (rld)
assay(dds) %>% head
assay(rld) %>% head

# The function plotPCA() requires two arguments as input: an rlog object and the intgroup (the column in our metadata that we are interested in).
# Create a PCA plot
library(ggplot2)
plotPCA(rld, intgroup="metastasis") + geom_text(aes(label=name),hjust="inward", vjust=2, size=2)

# Create a hierarchical clustering plot
library(pheatmap)
library(RColorBrewer)
sampleDists <- dist(t(assay(rld)))
sampleDistMatrix <- as.matrix( sampleDists )
rownames(sampleDistMatrix) <- rld$metastasis
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         col = colors)



# Run the differential expression pipeline on the raw counts
dds <- DESeq(dds)

# Obtain results for specific comparisons
MTvsNM <-results(dds, contrast=c("metastasis","MT","NM"), independentFiltering = TRUE , alpha = 0.05)


summary(MTvsNM)
head(MTvsNM)
table(MTvsNM$padj < 0.05)
MTvsNM[order(MTvsNM$padj),] %>% head

# Write the results to a file
write.table(as.data.frame(MTvsNM[order(MTvsNM$padj),] ), file="MT_vs_NM_dge.txt",sep="\t", quote = FALSE)


# Plot expression for a single gene - used genes of intrest and then top differetially expressed genes.
plotCounts(dds, gene="BAP1", intgroup="metastasis") 
plotCounts(dds, gene="GNAQ", intgroup="metastasis") 
plotCounts(dds, gene="GNA11", intgroup="metastasis") 
plotCounts(dds, gene="HOXC6", intgroup="metastasis") 
plotCounts(dds, gene="COX6A2", intgroup="metastasis") 
plotCounts(dds, gene="LOC731631", intgroup="metastasis") 
plotCounts(dds, gene="PIFO", intgroup="metastasis") 


# Identify the names of the top 20 significantly differentially expressed genes
MTvsNM_sorted <- MTvsNM[order(MTvsNM$padj),]
MTvsNM_top20 <- head(MTvsNM_sorted, n=20)
top20_genes_MTvsNM <- rownames(MTvsNM_top20)

# Extract rlog-transformed values into a matrix and create a heatmap
rlog.dge <- rld[top20_genes_MTvsNM,] %>% assay
pheatmap(rlog.dge, scale="row", main = "Differential Gene Expression (row-based z-score)")


# Create a tibble dataframe of results
heatmap

library(dplyr)

# Obtain logical vector where TRUE values denote padj values < 0.05; mutate() adds new variables and preserves existing ones
library(dplyr)
MTvsNM_tb <- MTvsNM_tb %>% mutate(threshold = padj < 0.05)
MTvsNM_tb <- MTvsNM_tb %>% arrange(padj) %>% mutate(genelabels = "")
MTvsNM_tb$genelabels[1:10] <- MTvsNM_tb $gene[1:10]

## Create a Volcano plot
library(ggrepel)
ggplot(MTvsNM_tb, aes(x = log2FoldChange, y = -log10(padj))) +
        geom_point(aes(colour = threshold)) +
        geom_text_repel(aes(label = genelabels)) +
        ggtitle("MTvsNM") +
        xlab("log2 fold change") + 
        ylab("-log10 adjusted p-value") +
        theme(legend.position = "none",
              plot.title = element_text(size = rel(1.5), hjust = 0.5),
              axis.title = element_text(size = rel(1.25))) 
